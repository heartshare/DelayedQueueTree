# DelayedQueueTree
延时队列技术研究


<pre>
应用场景:
       订单超时取消？
       订单完成后超时未评论系统添加默认评论？

数据量小的情况下简单的定时任务轮询即可解决。

当数据量比较大的时候，高频的轮询就会比较耗费资源，导致数据库的慢查询或者查询超时。

在这种情况下，处理这类需求可以采用延时队列来完成
</pre>

<pre>
另一种解决方案
     1：因为订单表一般比较大，避免全表扫描，而且定时扫描不实时，建立针对订单的定时任务。
     2：生成订单时，在任务表中插入一条记录，主要包括订单号，创建时间，任务状态
     3：建立一个总的定时任务，定时去扫描订单任务表，发现超时的订单，根据订单号关闭订单
     5：定期清理任务，把已经执行过定时任务，已经处理过的任务关闭，保证任务表不至于特别大，
        执行效率也比较高。
</pre>

<pre>
几种延时队列：
      1）Java.util.concurrent.DelayQueue
         优点：JDK自身实现，方便，支持数据量有限
      2）RocketMQ延时队列
         优点：消息持久化，分布式
         缺点：不支持任意时间精度，只支持特定level的延时消息。
</pre>
